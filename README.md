Давайте разберем каждый вопрос по очереди:

### 1) Хеширование. Полиномиальная хеш-функция. Поиск подстроки в строке при помощи хешей (алгоритм Рабина-Карпа). Оценка времени выполнения.

**Хеширование:**
Хеширование представляет собой процесс преобразования входных данных произвольной длины в хеш-значение фиксированной длины. Основное свойство хеш-функции — быстрое вычисление хеша для любого входа.

**Полиномиальная хеш-функция:**
Полиномиальная хеш-функция используется для преобразования строки в хеш-значение. Одним из примеров может быть хеш-функция, вычисляющая значение как сумму всех символов строки, умноженных на степени простого числа. Пример: для строки "abc" с хеш-функцией h(s) = s[0]*p^2 + s[1]*p^1 + s[2]*p^0, где p — простое число.

**Алгоритм Рабина-Карпа:**
Алгоритм Рабина-Карпа используется для быстрого поиска всех вхождений образца (подстроки) в строке, используя хеш-функции для сравнения подстрок и строк. Суть в том, чтобы вычислить хеш для образца и для всех возможных подстрок строки, сравнивая их хеши. Это позволяет снизить сложность с O(n*m) до O(n + m), где n — длина строки, m — длина образца.

**Оценка времени выполнения:**
Алгоритм Рабина-Карпа имеет оценку времени выполнения O(n + m), где n — длина строки, m — длина образца. Это объясняется тем, что время на вычисление хешей для образца и каждой подстроки строки является линейным.

### 2) Z-функция, понятие z-блока. Пи-функция. Определения. Алгоритмы построения. Оценка времени выполнения.

**Z-функция:**
Z-функция для строки S длины n — это массив Z, где Z[i] — длина наибольшего префикса подстроки, начинающегося с i, который совпадает с префиксом строки S. Z-блок — непрерывная часть строки, где Z-значения равны длине этого блока. 

**Пи-функция:**
Пи-функция для строки S длины n — это массив Pi, где Pi[i] — количество символов, на которое строка S совпадает с её префиксом, заканчивающимся в позиции i.

**Алгоритмы построения:**
- **Z-функция:** Может быть построена за O(n) времени.
  - Используется алгоритмом "сжатия правой границы".
  - Проходит по строке и поддерживает правую границу самого правого Z-блока и связанный с ней самый левый Z-блок.

- **Пи-функция:** Также строится за O(n) времени.
  - Использует алгоритм "построения префикс-функции".
  - Поэтапно вычисляет значения Pi[i] для каждой позиции i строки.

### 3) Алгоритм Дейкстры. Постановка задачи, описание алгоритма за O(V^2 + E). Улучшение алгоритма для разреженных графов за O(ElogV).

**Постановка задачи:**
Алгоритм Дейкстры используется для нахождения кратчайших путей от одной начальной вершины до всех остальных вершин во взвешенном графе.

**Описание алгоритма за O(V^2 + E):**
- Используется массив расстояний dist и множество посещенных вершин.
- Начинается с начальной вершины, расстояние до нее становится равным 0.
- Выбирается вершина с минимальным расстоянием из множества необработанных вершин, обновляются расстояния до смежных вершин.
- Для плотных графов имеет сложность O(V^2).

**Улучшение для разреженных графов за O(ElogV):**
- Используется очередь с приоритетом (куча), где хранятся вершины с их текущими расстояниями.
- Позволяет эффективно выбирать и обновлять ближайшие вершины.
- Подходит для разреженных графов с малым числом ребер по сравнению с числом вершин.

### 4) Динамическое программирование. Основные понятия. Задача о кузнечике. Задача о черепашке. Оценка времени выполнения.

**Основные понятия:**
Динамическое программирование — метод решения сложных задач, разбитых на более простые подзадачи, с сохранением решений подзадач для избежания повторных вычислений.

**Задача о кузнечике и черепашке:**
- **Кузнечик:** Может прыгать на одну или две клетки вперед. Задача — найти количество способов достичь клетки N.
- **Черепашка:** Может двигаться только вправо и вниз. Задача — найти количество путей до заданной клетки (m, n) в матрице.

**Оценка времени выполнения:**
- В зависимости от задачи, время выполнения может быть O(n) или O(n*m), где n и m — размерности пространства задачи.

### 5) Задача о рюкзаке: постановка классической задачи, решение методом динамического программирования, оценка времени работы.

**Постановка задачи:**
Даны предметы с заданными весами и стоимостями. Необходимо выбрать подмножество предметов так, чтобы их суммарный вес не превышал заданный предел, а суммарная стоимость была максимальной.

**Решение методом динамического программирования:**
- Создание таблицы dp, где dp[i][w] — максимальная стоимость предметов, которую можно унести среди первых i предметов, имея вес не больше w.
- Заполнение таблицы поочередно для каждого предмета и каждого возможного веса.
- Время работы O(n*W), где n — количество предметов, W — вместимость рюкзака.

уменьшить глубину дерева и ускорить будущие операции.

- **Эвристика сжатия пути:** При операции поиска корня для каждого узла на пути к корню каждый узел напрямую связывается с корнем, чтобы улучшить будущие запросы.

**Асимптотика операций:**
- **Union (объединение двух множеств):** Амортизированная сложность O(α(n)), где α — обратная функция Аккермана, что практически является константой, что делает операцию очень эффективной.
- **Find (поиск корня множества):** Очень близка к O(α(n)), так как сжатие пути помогает уменьшить высоту дерева.

**6) Задача поиска наибольшей возрастающей подпоследовательности в массиве:**

**Решение за O(N^2) методом динамического программирования:**
- Создаем массив dp, где dp[i] будет содержать длину наибольшей возрастающей подпоследовательности, заканчивающейся в элементе i.
- Инициализируем dp[i] = 1 для всех i от 0 до N-1.
- Для каждого i от 1 до N-1, перебираем все предыдущие элементы j (от 0 до i-1). Если nums[j] < nums[i], то обновляем dp[i] = max(dp[i], dp[j] + 1).
- Находим максимальное значение в массиве dp, которое и будет длиной наибольшей возрастающей подпоследовательности.
- Время выполнения: O(N^2), так как каждый элемент перебирается с каждым.

**Решение за O(NlogN) методом динамического программирования:**
- Используем двоичный поиск для эффективного нахождения места вставки текущего элемента в массив, который будет хранить текущие значения подпоследовательностей.
- Создаем массив tails, где tails[i] будет содержать минимальное конечное значение для всех подпоследовательностей длины i+1.
- Итерируемся по элементам исходного массива. Для каждого элемента nums[i]:
  - Используем двоичный поиск для нахождения наименьшего индекса k, такого что tails[k] >= nums[i]. Этот шаг помогает нам обновлять текущие значения подпоследовательностей более эффективно.
  - Если такой индекс найден, заменяем tails[k] на nums[i].
  - Если такого индекса нет, добавляем nums[i] в конец массива tails для увеличения длины наибольшей подпоследовательности.
- В конце длина массива tails будет содержать длину наибольшей возрастающей подпоследовательности.
- Время выполнения: O(NlogN), так как для каждого элемента выполняется двоичный поиск.

### 7) Задача поиска длины наибольшей общей подпоследовательности двух строк:

**Решение за O(N*M) методом динамического программирования:**
- Создаем двумерный массив dp, где dp[i][j] будет содержать длину наибольшей общей подпоследовательности для первых i символов первой строки и первых j символов второй строки.
- Инициализируем dp[i][0] = 0 и dp[0][j] = 0 для всех i и j.
- Для каждой пары (i, j), где i и j > 0:
  - Если s1[i-1] == s2[j-1], то dp[i][j] = dp[i-1][j-1] + 1.
  - Иначе, dp[i][j] = max(dp[i-1][j], dp[i][j-1]).
- В dp[N][M] будет содержаться длина наибольшей общей подпоследовательности.
- Время выполнения: O(N*M), где N и M — длины двух строк.

### 8) Поиск суммы на отрезке + изменение значения в массиве:

**Постановка задачи:**
Дан массив чисел. Необходимо реализовать структуру данных, которая позволяет эффективно находить сумму элементов на отрезке и изменять значение элемента.

**Решение за O(logN) при помощи дерева отрезков:**
- **Построение дерева отрезков:**
  - Создается сегментное дерево, в котором каждый лист соответствует элементу исходного массива, а внутренние узлы содержат сумму отрезка, покрываемого дочерними узлами.
  - Строится дерево для заданного массива за O(N) времени.
  
- **Оценка времени выполнения:**
  - **Вставка (изменение значения элемента):** О(logN) — обновление значений в листьях и пересчет суммы вверх по дереву.
  - **Запрос суммы на отрезке:** О(logN) — суммирование значений по пути от корня до листа в дереве.

### 9) Поиск минимума на отрезке + изменение значения в массиве:

**Постановка задачи:**
Аналогично предыдущей задаче, но теперь требуется находить минимум на отрезке и изменять значения элементов.

**Решение за O(logN) при помощи дерева отрезков:**
- **Построение дерева отрезков:**
  - Создается сегментное дерево, в котором каждый лист соответствует элементу исходного массива, а внутренние узлы содержат минимум на отрезке, покрываемом дочерними узлами.
  - Строится дерево для заданного массива за O(N) времени.
  
- **Оценка времени выполнения:**
  - **Изменение значения элемента:** О(logN) — обновление значений в листьях и пересчет минимума вверх по дереву.
  - **Запрос минимума на отрезке:** О(logN) — поиск минимума по пути от корня до листа в дереве.

### 10) Алгоритм Форда-Беллмана:

**Описание алгоритма:**
Алгоритм Форда-Беллмана используется для нахождения кратчайших путей от одной начальной вершины до всех остальных в ориентированном или неориентированном графе с ребрами с весами, возможно, отрицательными.

- Инициализируем расстояние до начальной вершины как 0, а до всех остальных как бесконечность.
- Производим релаксацию всех ребер (V-1) раз, где V — количество вершин в графе. Релаксация заключается в обновлении расстояний до вершин, если найден более короткий путь.
- При обнаружении отрицательного цикла, алгоритм сообщает об этом.

**Оценка времени выполнения:**
- Сложность алгоритма Форда-Беллмана составляет O(V * E), где V — количество вершин, E — количество ребер в графе.

### 11) Система непересекающихся множеств:

**Описание структуры:**
Система непересекающихся множеств — это структура данных, которая поддерживает множество непересекающихся множеств (или групп), каждое из которых представлено одним из его элементов.

- **Эвристика по размеру:** При объединении двух множеств выбирается корень меньшего дерева и прикрепляется к корню большего дерева, чтобы

### 12) Алгоритм Краскала:

**Описание алгоритма:**
Алгоритм Краскала используется для построения минимального остовного дерева взвешенного связного графа. Он работает на основе системы непересекающихся множеств.

- **Шаги алгоритма:**
  1. Сортировка всех ребер по весу.
  2. Итеративное добавление ребер к остову, начиная с самых легких, при условии что добавление ребра не создает цикл в остовном дереве (проверка с помощью системы непересекающихся множеств).

- **Применение системы непересекающихся множеств:** Используется для эффективного определения, принадлежат ли две вершины одному множеству (циклу) в текущем остове.

**Асимптотика:**
- Сложность алгоритма Краскала зависит от сортировки ребер, что обычно составляет O(E log E). Поскольку E ≤ V^2, где V — количество вершин, сложность может быть сведена к O(E log V).

### 13) Двоичные деревья поиска:

**Построение, добавление элемента, удаление элемента:**
- **Построение:** Последовательное добавление каждого элемента таким образом, чтобы при вставке учитывался порядок сортировки (левое поддерево меньше текущего узла, а правое — больше).
- **Добавление элемента:** Находится место для вставки, создается новый узел и он вставляется в дерево в соответствии с порядком.
- **Удаление элемента:** В случае удаления узла, его потомки перестраиваются так, чтобы сохранить порядок дерева.

**Примеры операций:**
- Построение:
  ```
        5
       / \
      3   8
     / \ / \
    2  4 6  9
  ```
- Добавление элемента 7:
  ```
        5
       / \
      3   8
     / \ / \
    2  4 6  9
            \
             7
  ```
- Удаление элемента 3:
  ```
        5
       / \
      4   8
     /   / \
    2   6   9
         \
          7
  ```

**Асимптотика операций:**
- **Поиск, вставка и удаление:** В сбалансированном дереве поиска время выполнения этих операций — O(log N), где N — количество элементов в дереве.

### 14) Декартово дерево:

**Построение, добавление элемента, удаление элемента, split, merge:**
- **Построение:** Последовательное добавление элементов, учитывая приоритет (обычно случайные числа), чтобы поддерживать свойство кучи и упорядоченности по ключам.
- **Добавление элемента:** Вставка элемента с учетом свойства кучи по ключам и приоритетам.
- **Удаление элемента:** Удаление элемента и перестройка дерева для поддержки свойства кучи.
- **Split:** Разделение дерева на два поддерева по ключу.
- **Merge:** Объединение двух декартовых деревьев в одно.

**Примеры операций:**
- Построение:
  ```
         5
        / \
       3   8
      / \ / \
     2  4 6  9
  ```
- Добавление элемента (7, priority=1):
  ```
         5
        / \
       3   8
      / \ / \
     2  4 6  9
           /
          7
  ```
- Удаление элемента 3:
  ```
         5
        / \
       4   8
      /   / \
     2   6  9
          /
         7
  ```

**Асимптотика операций:**
- **Поиск, вставка и удаление:** В среднем случае время выполнения этих операций — O(log N), где N — количество элементов в дереве.

### 15) Хеш-таблицы с открытой адресацией, метод цепочек:

**Асимптотика операций работы с хеш-таблицами (вставка, удаление):**
- **Вставка и удаление:** В среднем случае время выполнения операций вставки и удаления в хеш-таблицах с открытой адресацией — O(1). Это предполагает, что фактор загрузки таблицы остается низким.
- **Поиск:** В среднем случае время выполнения операции поиска также O(1).

**Метод цепочек:**
- При коллизии элементы хранятся в виде связного списка или другой структуры данных внутри одной ячейки хеш-таблицы.
- Операции вставки и удаления требуют времени O(1 + α), где α — коэффициент загрузки таблицы.

Таким образом, каждый из этих алгоритмов и структур данных представляет собой важный инструмент в компьютерной науке и программировании, обеспечивая эффективное решение разнообразных задач.
