Давайте разберем каждый вопрос по очереди:

### 1) Хеширование. Полиномиальная хеш-функция. Поиск подстроки в строке при помощи хешей (алгоритм Рабина-Карпа). Оценка времени выполнения.

**Хеширование:**
Хеширование представляет собой процесс преобразования входных данных произвольной длины в хеш-значение фиксированной длины. Основное свойство хеш-функции — быстрое вычисление хеша для любого входа.

**Полиномиальная хеш-функция:**
Полиномиальная хеш-функция используется для преобразования строки в хеш-значение. Одним из примеров может быть хеш-функция, вычисляющая значение как сумму всех символов строки, умноженных на степени простого числа. Пример: для строки "abc" с хеш-функцией h(s) = s[0]*p^2 + s[1]*p^1 + s[2]*p^0, где p — простое число.

**Алгоритм Рабина-Карпа:**
Алгоритм Рабина-Карпа используется для быстрого поиска всех вхождений образца (подстроки) в строке, используя хеш-функции для сравнения подстрок и строк. Суть в том, чтобы вычислить хеш для образца и для всех возможных подстрок строки, сравнивая их хеши. Это позволяет снизить сложность с O(n*m) до O(n + m), где n — длина строки, m — длина образца.

**Оценка времени выполнения:**
Алгоритм Рабина-Карпа имеет оценку времени выполнения O(n + m), где n — длина строки, m — длина образца. Это объясняется тем, что время на вычисление хешей для образца и каждой подстроки строки является линейным.

### 2) Z-функция, понятие z-блока. Пи-функция. Определения. Алгоритмы построения. Оценка времени выполнения.

**Z-функция:**
Z-функция для строки S длины n — это массив Z, где Z[i] — длина наибольшего префикса подстроки, начинающегося с i, который совпадает с префиксом строки S. Z-блок — непрерывная часть строки, где Z-значения равны длине этого блока. 

**Пи-функция:**
Пи-функция для строки S длины n — это массив Pi, где Pi[i] — количество символов, на которое строка S совпадает с её префиксом, заканчивающимся в позиции i.

**Алгоритмы построения:**
- **Z-функция:** Может быть построена за O(n) времени.
  - Используется алгоритмом "сжатия правой границы".
  - Проходит по строке и поддерживает правую границу самого правого Z-блока и связанный с ней самый левый Z-блок.

- **Пи-функция:** Также строится за O(n) времени.
  - Использует алгоритм "построения префикс-функции".
  - Поэтапно вычисляет значения Pi[i] для каждой позиции i строки.

### 3) Алгоритм Дейкстры. Постановка задачи, описание алгоритма за O(V^2 + E). Улучшение алгоритма для разреженных графов за O(ElogV).

**Постановка задачи:**
Алгоритм Дейкстры используется для нахождения кратчайших путей от одной начальной вершины до всех остальных вершин во взвешенном графе.

**Описание алгоритма за O(V^2 + E):**
- Используется массив расстояний dist и множество посещенных вершин.
- Начинается с начальной вершины, расстояние до нее становится равным 0.
- Выбирается вершина с минимальным расстоянием из множества необработанных вершин, обновляются расстояния до смежных вершин.
- Для плотных графов имеет сложность O(V^2).

**Улучшение для разреженных графов за O(ElogV):**
- Используется очередь с приоритетом (куча), где хранятся вершины с их текущими расстояниями.
- Позволяет эффективно выбирать и обновлять ближайшие вершины.
- Подходит для разреженных графов с малым числом ребер по сравнению с числом вершин.

### 4) Динамическое программирование. Основные понятия. Задача о кузнечике. Задача о черепашке. Оценка времени выполнения.

**Основные понятия:**
Динамическое программирование — метод решения сложных задач, разбитых на более простые подзадачи, с сохранением решений подзадач для избежания повторных вычислений.

**Задача о кузнечике и черепашке:**
- **Кузнечик:** Может прыгать на одну или две клетки вперед. Задача — найти количество способов достичь клетки N.
- **Черепашка:** Может двигаться только вправо и вниз. Задача — найти количество путей до заданной клетки (m, n) в матрице.

**Оценка времени выполнения:**
- В зависимости от задачи, время выполнения может быть O(n) или O(n*m), где n и m — размерности пространства задачи.

### 5) Задача о рюкзаке: постановка классической задачи, решение методом динамического программирования, оценка времени работы.

**Постановка задачи:**
Даны предметы с заданными весами и стоимостями. Необходимо выбрать подмножество предметов так, чтобы их суммарный вес не превышал заданный предел, а суммарная стоимость была максимальной.

**Решение методом динамического программирования:**
- Создание таблицы dp, где dp[i][w] — максимальная стоимость предметов, которую можно унести среди первых i предметов, имея вес не больше w.
- Заполнение таблицы поочередно для каждого предмета и каждого возможного веса.
- Время работы O(n*W), где n — количество предметов, W — вместимость рюкзака.

уменьшить глубину дерева и ускорить будущие операции.

- **Эвристика сжатия пути:** При операции поиска корня для каждого узла на пути к корню каждый узел напрямую связывается с корнем, чтобы улучшить будущие запросы.

**Асимптотика операций:**
- **Union (объединение двух множеств):** Амортизированная сложность O(α(n)), где α — обратная функция Аккермана, что практически является константой, что делает операцию очень эффективной.
- **Find (поиск корня множества):** Очень близка к O(α(n)), так как сжатие пути помогает уменьшить высоту дерева.

### 12) Алгоритм Краскала:

**Описание алгоритма:**
Алгоритм Краскала используется для построения минимального остовного дерева взвешенного связного графа. Он работает на основе системы непересекающихся множеств.

- **Шаги алгоритма:**
  1. Сортировка всех ребер по весу.
  2. Итеративное добавление ребер к остову, начиная с самых легких, при условии что добавление ребра не создает цикл в остовном дереве (проверка с помощью системы непересекающихся множеств).

- **Применение системы непересекающихся множеств:** Используется для эффективного определения, принадлежат ли две вершины одному множеству (циклу) в текущем остове.

**Асимптотика:**
- Сложность алгоритма Краскала зависит от сортировки ребер, что обычно составляет O(E log E). Поскольку E ≤ V^2, где V — количество вершин, сложность может быть сведена к O(E log V).

### 13) Двоичные деревья поиска:

**Построение, добавление элемента, удаление элемента:**
- **Построение:** Последовательное добавление каждого элемента таким образом, чтобы при вставке учитывался порядок сортировки (левое поддерево меньше текущего узла, а правое — больше).
- **Добавление элемента:** Находится место для вставки, создается новый узел и он вставляется в дерево в соответствии с порядком.
- **Удаление элемента:** В случае удаления узла, его потомки перестраиваются так, чтобы сохранить порядок дерева.

**Примеры операций:**
- Построение:
  ```
        5
       / \
      3   8
     / \ / \
    2  4 6  9
  ```
- Добавление элемента 7:
  ```
        5
       / \
      3   8
     / \ / \
    2  4 6  9
            \
             7
  ```
- Удаление элемента 3:
  ```
        5
       / \
      4   8
     /   / \
    2   6   9
         \
          7
  ```

**Асимптотика операций:**
- **Поиск, вставка и удаление:** В сбалансированном дереве поиска время выполнения этих операций — O(log N), где N — количество элементов в дереве.

### 14) Декартово дерево:

**Построение, добавление элемента, удаление элемента, split, merge:**
- **Построение:** Последовательное добавление элементов, учитывая приоритет (обычно случайные числа), чтобы поддерживать свойство кучи и упорядоченности по ключам.
- **Добавление элемента:** Вставка элемента с учетом свойства кучи по ключам и приоритетам.
- **Удаление элемента:** Удаление элемента и перестройка дерева для поддержки свойства кучи.
- **Split:** Разделение дерева на два поддерева по ключу.
- **Merge:** Объединение двух декартовых деревьев в одно.

**Примеры операций:**
- Построение:
  ```
         5
        / \
       3   8
      / \ / \
     2  4 6  9
  ```
- Добавление элемента (7, priority=1):
  ```
         5
        / \
       3   8
      / \ / \
     2  4 6  9
           /
          7
  ```
- Удаление элемента 3:
  ```
         5
        / \
       4   8
      /   / \
     2   6  9
          /
         7
  ```

**Асимптотика операций:**
- **Поиск, вставка и удаление:** В среднем случае время выполнения этих операций — O(log N), где N — количество элементов в дереве.

### 15) Хеш-таблицы с открытой адресацией, метод цепочек:

**Асимптотика операций работы с хеш-таблицами (вставка, удаление):**
- **Вставка и удаление:** В среднем случае время выполнения операций вставки и удаления в хеш-таблицах с открытой адресацией — O(1). Это предполагает, что фактор загрузки таблицы остается низким.
- **Поиск:** В среднем случае время выполнения операции поиска также O(1).

**Метод цепочек:**
- При коллизии элементы хранятся в виде связного списка или другой структуры данных внутри одной ячейки хеш-таблицы.
- Операции вставки и удаления требуют времени O(1 + α), где α — коэффициент загрузки таблицы.

Таким образом, каждый из этих алгоритмов и структур данных представляет собой важный инструмент в компьютерной науке и программировании, обеспечивая эффективное решение разнообразных задач.
